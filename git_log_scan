#!/usr/bin/env bash

enable $( enable_ate )
enable $( enable_pwb )

source $( ate_sources ate_exit_on_error )
source $( pwb_sources pwb_exit_on_error )

head_newline_emptied()
{
    local -i col="${1:-5}"
    # 1B down one row
    # 2G move to column on same row
    # 2K erase to end of line
    printf $'\e[1B\e[%dG\e[2K' "$col"
}

clear_comrec() { comrec=( "" "" "" "" "" "" "" ); }

declare ROW_SIZE=7
declare -n commit_hash="comrec[0]"
declare -n commit_decoration="comrec[1]"
declare -n commit_author="comrec[2]"
declare -n commit_date="comrec[3]"
declare -n commit_title="comrec[4]"
declare -n commit_message="comrec[5]"
declare -n commit_merge="comrec[6]"

# Test to confirm clear_comrec makes the expected (ROW_SIZE) length array:
clear_comrec
if [ "${#comrec[*]}" -ne "$ROW_SIZE" ]; then
    echo "Comrec array size must match ROW_SIZE constant."
    exit
fi

declare -a re_commit_array=(
    ^
    commit
    [[:space:]]
    \(                # capture group #1 for commit hash value
       [[:xdigit:]]+
    \)
    \(                # conditional group #2 of optional decoration
       [[:space:]]*
       \\\(           # match opening raw parenthesis
       \(             # capture group #3 for contents of decoration
          [^)]+    # capture to close raw parentesis
       \)
       \\\)
    \)?               # end of conditional group #2
    $
)

declare OIFS="$IFS"
IFS=''
declare re_commit="${re_commit_array[*]}"
IFS="$OIFS"
unset OIFS

scan_git_log()
{
    local tname="$1"

    # Confirm appropriate configuration
    ate get_row_size "$tname" -v row_size
    ate_exit_on_error
    if [ "$row_size" -lt "$ROW_SIZE" ]; then
        echo "Invalid row size of $row_size should be $ROW_SIZE"
        exit
    fi

    local OIFS="$IFS"
    local IFS=$' '

    # Directly use hosted array
    ate get_array_name "$tname" -v aname
    ate_exit_on_error
    local -n sgl_array="$aname"

    local -i text_state=0
    local curline
    local -a text_block=()
    local -i commit_count=0

    local -a comrec
    clear_comrec

    while IFS= read -r curline; do
        if [[ "$curline" =~ ^[[:space:]]+([^[:space:]].*) ]]; then
            text_block+=( "${BASH_REMATCH[1]}" )
        elif [[ "$curline" =~ $re_commit ]]; then
            # If currec has contents, save and clear it:
            if [ -n "$commit_hash" ]; then
                if [ "${#text_block[*]}" -ne 0 ]; then
                    commit_message="${text_block[*]}"
                fi

                sgl_array+=( "${comrec[@]}" )
                text_state=0
                clear_comrec
            fi
            text_block=()
            text_state=0
            # Start next commit record
            commit_hash="${BASH_REMATCH[1]}"
            commit_decoration="${BASH_REMATCH[3]}"
        elif [[ "$curline" =~ ^Author:\ +([^\)]+)$ ]]; then
            commit_author="${BASH_REMATCH[1]}"
        elif [[ "$curline" =~ ^Date:\ *([^\)]+)$ ]]; then
            commit_date="${BASH_REMATCH[1]}"
            elif [[ "$curline" =~ ^Merge:\ +([^\)]+)$ ]]; then
            commit_merge="${BASH_REMATCH[1]}"
        elif [[ "$curline" =~ ^[[:space:]]*$ ]]; then
            (( ++text_state ))
            if (( text_state == 2 )); then
                commit_title="${text_block[*]}"
                text_block=()
            elif (( text_state > 2 )); then
                text_block+=( $'\nBOO\n' )
            fi
        fi
    done < <( git --no-pager log --date=iso-strict --pretty=medium --decorate=full)

    # Save final commit record, not followed by a "commit" line
    if [ -n "$commit_hash" ]; then
        if [ "${#text_block[*]}" -ne 0 ]; then
            if [ "$text_state" -lt 2 ]; then
                commit_title="${text_block[*]}"
            else
                commit_message="${text_block[*]}"
            fi
        fi
        sgl_array+=( "${comrec[@]}" )
        clear_comrec
    fi

    ate index_rows "$tname"
    ate_exit_on_error
}

###########################
### PWB Print Functions ###
###########################

gl_print_line()
{
    local -i index="$1"
    local tname="$2"
    local -i char_count="$3"

    local -a comrec

    ate get_row "$tname" "$index" -a comrec
    ate_exit_on_error

    local pline
    printf -v pline "%s (%s): %-*s" "${commit_date:0:10}" "${commit_hash:0:8}" "$char_count" "${commit_title}"

    if [ -n "$commit_decoration" ]; then
        printf $'\e[35;1m'
    fi

    printf "${pline:0:$char_count}"

    if [ -n "$commit_decoration" ]; then
        printf $'\e[m'
    fi
}

gl_print_top()
{
    local -i index="$1"
    local tname="$2"
    local -i char_count="$3"

    local -a comrec

    ate get_row "$tname" "$index" -a comrec
    ate_exit_on_error

    # Empty line
    printf $'\e[2K'

    printf "%s %s" "${commit_hash:0:8}" "${commit_date:0:10}"
    head_newline_emptied 5
    printf "     Title: %s" "$commit_title"
    head_newline_emptied 5
    printf "    Author: %s" "$commit_author"

    if [ -n "$commit_merge" ]; then
        head_newline_emptied 5
        printf "     Merge: %s" "$commit_merge"
    fi

    if [ -n "$commit_decoration" ]; then
        head_newline_emptied 5
        printf "Decoration: %s" "$commit_decoration"
    fi
}


#######################
### BEGIN EXECUTION ###
#######################

# Exit quickly if we detect that git not initiated
if ! git status >/dev/null 2>&1; then
    echo "Git not configured here, '$PWD'"
    exit
fi

declare gl_table
ate declare gl_table "$ROW_SIZE"
ate_exit_on_error

scan_git_log gl_table
ate get_row_count gl_table -v row_count
ate_exit_on_error

declare gl_display
pwb declare gl_display gl_table "$row_count" gl_print_line -t gl_print_top
pwb_exit_on_error
pwb set_margins gl_display 5 4 1
pwb_exit_on_error

pwb init
pwb start gl_display
pwb_exit_on_error
pwb restore
