#!/usr/bin/env bash

##########################
###   DATA FUNCTIONS   ###
##########################

# Filtering works by appending an integer state tag to the end
# if each file name.  During sort/filter, sort puts identical
# names consecutively, and filter works by always saving the
# record with the highest state tag when two records have the
# same name.
#
# So...both for both sort/filter functions, the tag values and
# assignments are made to give preference to the final desired
# outcome.

get_full_file_list()
{
    local -n gffl_return="$1"

    # Get inventory of ALL files
    local -a gffl_files
    while read -r; do
        gffl_files+=( "${REPLY}${DELIM}$IGNORED" )
    done < <( find * )

    # Interleave with git-registered files
    while read -r; do
        gffl_files+=( "${REPLY}${DELIM}$COMMITTED" )
    done < <( git ls-files )

    # Sort and filter to differentiate registered and non-registered files
    local IFS=$'\n'
    local -a last_row cur_row
    while read -r; do
        # gffl_return+=( "$REPLY" )
        if [ "${#last_row[*]}" -eq 0 ]; then
            IFS="$DELIM" read -r -a last_row <<< "$REPLY"
            gffl_return+=( "$REPLY" )
        else
            IFS="$DELIM" read -r -a cur_row <<< "$REPLY"
            if [[ "${cur_row[0]}" != "${last_row[0]}" ]]; then
                gffl_return+=( "$REPLY" )
            fi
            last_row=( "${cur_row[@]}" )
        fi
    done < <( sort <<< "${gffl_files[*]}" )
}

get_context_data()
{
    local -n gcd_return="$1"

    # Get list of files, categorized as registered or not
    local -a gcd_raw_files
    get_full_file_list gcd_raw_files

    local state=none
    local cur_regex

    # Interleave with categorized registered files (committed files
    # will be missing, but will be included from gcd_raw_files
    while IFS='' read -r; do
        if [[ "$state" == none ]]; then
            case "$REPLY" in
                "Changes to be committed:" )
                    state="$STAGED"
                    cur_regex=$'^\t[^:]+:[[:space:]]{2,}([^[:space:]].*)$'
                    ;;
                "Changes not staged for commit:" )
                    state="$CHANGED"
                    cur_regex=$'^\t[^:]+:[[:space:]]{2,}([^[:space:]].*)$'
                    ;;
                "Untracked files:" )
                    state="$UNTRACKED"
                    cur_regex=$'^\t(.*)$'
                    ;;
            esac
            continue
        elif [[ "$REPLY" =~ ^[[:space:]]*$ ]]; then
            state=none
        elif [[ "$REPLY" =~ $cur_regex ]]; then
            gcd_raw_files+=( "${BASH_REMATCH[1]}${DELIM}${state}" )
        fi
    done < <( git status )

    # Sort and filter to have every file categorized:
    IFS=$'\n'
    local -a last_row cur_row
    while read -r; do
        if [ "${#last_row[*]}" -eq 0 ]; then
            IFS="$DELIM" read -r -a last_row <<< "$REPLY"
        else
            IFS="$DELIM" read -r -a cur_row <<< "$REPLY"
            if [[ "${cur_row[0]}" == "${last_row[0]}" ]]; then
                gcd_return+=( "$REPLY" )
                last_row=()
            else
                IFS="$DELIM"
                gcd_return+=( "${last_row[*]}" )
                IFS=$'\n'
                last_row=( "${cur_row[@]}" )
            fi
        fi
    done < <( sort <<< "${gcd_raw_files[*]}" )
}

###########################
###   BOUND FUNCTIONS   ###
###########################

exec_help()
{
    local eh_keyp
    pwb_keybinder help KBINDINGS -v eh_keyp

    shift
    exec_line "$eh_keyp" "$@"
    local -i ecode="$?"
    if [[ "$eh_keyp" == 'q' ]] || [ "$ecode" -ne 0 ]; then
        return 1
    fi
}

exec_return()
{
    return 1
}

exec_open()
{
    local -n eo_array="$3"
    local eo_line="${eo_array[$2]}"

    if [[ "${eo_line:0:1}" == \* ]]; then
        eo_line="${eo_line:1}"
        DIR_STEPS+=( "$eo_line" )
        local EO_OG_DIR="$PWD"
        cd "$eo_line"
        printf $'\e[H\e[2J'
        start_instance
        DIR_STEPS=( "${DIR_STEPS[@]:0:${#DIR_STEPS[*]}-1}" )
        cd "$EO_OG_DIR"
    fi
    return 0
}


#########################
###   PWB CALLBACKS   ###
#########################

print_line()
{
    local -n pl_dsource="$2"
    local -a pl_row
    local IFS="$DELIM"
    read -a pl_row <<< "${pl_dsource[$1]}"
    local color
    case "${pl_row[1]}" in
        "$IGNORED" )   color=1 ;;
        "$CHANGED" )   color=31 ;;
        "$STAGED"  )   color=32\;2 ;;
        "$COMMITTED" ) color=32\;1 ;;
        "$UNTRACKED" ) color=2 ;;
    esac

    printf -v tline $'\e[%sm%-*.*s\e[39;22m' "$color" "$3" "$3" "${pl_row[0]}"
    pwb limit_print "$3" "$tline"
}

noop_print_left() { :; }
print_left()
{
    local -i index="$1"
    local pl_handle="$5"

    local limit_args=(
        -t "${SI_REGIONS[LM_TOP]}"
        -c "${SI_REGIONS[LM_LINES]}"
        -l "${SI_REGIONS[LM_LEFT]}"
        -w "${SI_REGIONS[LM_WIDE]}"
    )

    local -i left=$(( SI_REGIONS[LM_WIDE] - 2 ))

    local -i rows top
    pwb get_data_count "$pl_handle" -v rows
    pwb get_top_row "$pl_handle" -v top

    local -a scrollbar_args=(
        -s "$rows"
        -t "$top"
        -v "${SI_REGIONS[LM_LINES]}"
    )

    local -a pl_scrollbar
    pwb_get_scroll_bar pl_scrollbar "${scrollbar_args[@]}"

    for block in "${pl_scrollbar[@]}"; do
        printf $'\e[%dG%s\e[1D\e[1E' "$left" "$block"
    done
}

print_top()
{
    local limit_args=(
        -t "${SI_REGIONS[TM_TOP]}"
        -c "${SI_REGIONS[TM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -a pt_lines=( "PWB TEMPLATE BASE" )

    local IFS="/"
    printf -v pt_lines["${#pt_lines[*]}"] "%s" "${DIR_STEPS[*]}"
    printf -v pt_lines["${#pt_lines[*]}"] "Press F1 for help"

    pwb_print_array pt_lines "${limit_args[@]}"
}

print_bottom()
{
    local limit_args=(
        -t "${SI_REGIONS[BM_TOP]}"
        -c "${SI_REGIONS[BM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -i index="$1"
    local -i total="${#SI_DATA[*]}"
    local -a lines
    printf -v lines[0] $'Record \e[33;1m%d\e[39;22m out of \e[33;1m%d\e[39;22m' \
           $(( index+1 )) "$total"

    pwb_print_array lines "${limit_args[@]}"
}


exec_line()
{
    local keyp="$1"
    local el_handle="$4"

    local -i ecode=0
    local el_func
    if pwb_keybinder func KEYFUNCS -v el_func -k "$keyp"; then
        "$el_func" "$@"
        ecode="$?"
        printf $'\e[H\e[2J'
        pwb print_all "$el_handle"
    fi

    return "$ecode"
}


###################################
###   INSTANCE PREP FUNCTIONS   ###
###################################

get_content_width()
{
    local -n gcw_wide="$1"
    local -n gcw_array="$2"

    local -i cur_wide
    gcw_wide=0
    for line in "${gcw_array[@]}"; do
        cur_wide="${#line}"
        (( gcw_wide = ( cur_wide >gcw_wide ? cur_wide : gcw_wide ) ))
    done
}

set_instance_margins()
{
    local sim_handle="$1"
    local sim_data="$2"

    local -i data_width
    get_content_width data_width "$sim_data"

    local -A sim_dims
    pwb get_dimensions -A sim_dims

    local -i non_content=$(( sim_dims[screen_cols] - data_width ))
    local -i left right
    (( right = non_content / 2 ))
    (( left = right + (non_content % 2) ))

    local -a sim_margins=( 5 "$right" 2 "$left" )

    pwb set_margins "$sim_handle" "${sim_margins[@]}"
}

start_instance()
{
    # Prepare Data
    local -a SI_DATA
    get_context_data SI_DATA
    local -i SI_DATA_COUNT="${#SI_DATA[*]}"

    if [ "$SI_DATA_COUNT" -eq 0 ]; then
        declare -a si_lines
        printf -v si_lines["${#si_lines[*]}"] \
               $'Directory \e[32;1m%s\e[39;22m is empty' "$PWD"
        si_lines+=(
            ""
            "Press any key to return."
        )
        pwb_conduct_dialog si_lines
    else
        local print_left_func=print_left
        p_print_left() { "$print_left_func" "$@"; }

        # Create Handle
        local -a declare_args=(
            SI_DATA
            "$SI_DATA_COUNT"
            print_line
            -e exec_line
            -b print_bottom
            -t print_top
            -l p_print_left
        )

        local SI_HANDLE
        pwb declare SI_HANDLE "${declare_args[@]}"
        pwb_exit_on_error

        # Prepare Handle
        set_instance_margins SI_HANDLE SI_DATA

        # With margins established, get instance-global regions
        local -A SI_REGIONS
        pwb_get_regions SI_REGIONS SI_HANDLE

        # Use do-nothing function for scrollbar not needed:
        if (( SI_DATA_COUNT <= SI_REGIONS[CO_LINES] )); then
            print_left_func=noop_print_left
        fi

        local ending_keyp
        declare -a start_args=(
            -a KEYMAP
            -k ending_keyp
        )

        pwb start SI_HANDLE "${start_args[@]}"
        pwb_exit_on_error

        if [[ "$ending_keyp" == 'q' ]]; then
            exit 0
        fi
    fi
}

#########################
###   MISCELLANEOUS   ###
#########################

exit_trap() { printf $'\e[H\e[2J'; pwb restore; cd "$OG_DIR"; }

############################
###   EXECUTION BEGINS   ###
############################

declare DELIM="|"

enable pwb

declare -a PSOURCES=(
    pwb_exit_on_error
    pwb_get_regions
    pwb_conduct_dialog
    pwb_print_array
    pwb_get_scroll_bar
    pwb_keybinder
)
source <( pwb_sources "${PSOURCES[@]}" )

declare -a KBINDINGS=(
    "key_f1"     exec_help   "Show help"
    "key_right"  exec_open   "Enter directory"
    "key_left"   exec_return "Exit directory"
    "key_escape" exec_return "Return"
)

declare -i COMMITTED=0
declare -i STAGED=1
declare -i CHANGED=2
declare -i IGNORED=3
declare -i UNTRACKED=4

declare KEYMAP
declare -a KEYFUNCS
pwb_keybinder prep KBINDINGS -v KEYMAP -f KEYFUNCS

trap exit_trap EXIT SIGINT SIGABRT
pwb init

declare OG_DIR="$PWD"
declare gffl_path=$( git rev-parse  --show-toplevel )
cd "$gffl_path"

start_instance

