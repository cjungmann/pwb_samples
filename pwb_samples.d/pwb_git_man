#!/usr/bin/env bash

##########################
###   DATA FUNCTIONS   ###
##########################

# Reverses names if name change detected,
# otherwise leave it alone.
massage_git_status_name()
{
    local -n mgsm_name="$1"

    if [[ "$mgsm_name" =~ ^(.*)\ -\>\ (.*)$ ]]; then
        mgsm_name="${BASH_REMATCH[2]} <- ${BASH_REMATCH[1]}"
    fi
}

record_from_status_line()
{
    local -n rfsl_record="$1"
    local rfsl_line="$2"

    if [[ "$rfsl_line" =~ (..)[[:space:]](.*)$ ]]; then
        local rfsl_status="${BASH_REMATCH[1]}"
        local rfsl_name="${BASH_REMATCH[2]}"
        massage_git_status_name rfsl_name

        rfsl_record="${rfsl_name}${DELIM}$rfsl_status"
        return 0
    fi

    return 1
}

get_context_data()
{
    local -n gcd_return="$1"

    local -a gcd_unordered

    # Start with list of TRACKED files, with a contrived empty status
    while read -r; do
        gcd_unordered+=( "$REPLY${DELIM}  " )
    done < <( git ls-files )

    local gcd_record

    # Add STATUS files, including untracked and ignored files
    while read -r; do
        if record_from_status_line gcd_record "$REPLY"; then
            gcd_unordered+=( "$gcd_record" )
        fi
    done < <( git status -s -u --ignored --porcelain )

    # The full list will include duplicates that are files that
    # are in the TRACKED list and the STATUS list.  Sorting will
    # group duplicates, with the STATUS instance sorting after
    # the assumed clean TRACKED instance.  Discard the first
    # if there are two instances.

    local lastrow
    local curname lastname

    while read -r; do
        curname="${REPLY%%${DELIM}*}"
        if [ -z "$lastname" ]; then
            lastname="$curname"
            lastrow="$REPLY"
            continue
        fi

        if [[ "$curname" == "$lastname" ]]; then
            gcd_return+=( "$REPLY" )
            lastname=""
        else
            gcd_return+=( "$lastrow" )
            lastrow="$REPLY"
            lastname="$curname"
        fi
    done < <( IFS=$'\n'; sort -i -t"$DELIM" -k1,1 <<< "${gcd_unordered[*]}" )
    # For possible future reference: to get ONLY the first field with 'sort',
    # you must specify both the beginning and end of the field, so -k1,1
    # will sort the string starting at field 1 (1-based indexes), and ENDS
    # with the end of field 1.  Without the end specification (-k1,x), the
    # field value is deemed to extend to the end of the line.

    if [ -n "$lastname" ]; then
        gcd_return+=( "$lastrow" )
    fi
}

# filter test functions for apply_filter function
af_clean() { [[ "$1" == "  " ]]; }
af_modified()   { [[ "$1" != "  " ]]; }
af_staged()     { [[ "${1:0:1}" =~ [MTADRCU] ]]; }
af_ignored()    { [[ "$1" == "!!" ]]; }
af_untracked()  { [[ "$1" == "??" ]]; }

apply_filters()
{
    local -n af_output="$1"
    local -n af_source="$2"
    local filter_type="$3"

    local ffunc="af_${filter_type}"
    local -a af_row
    local IFS="$DELIM"

    for gfile in "${af_source[@]}"; do
        read -r -a af_row <<< "$gfile"

        local ftype="${af_row[1]}"
        local -i type_index=-1

        if af_untracked "$ftype"; then
            type_index=4
        elif af_ignored "$ftype"; then
            type_index=3
        elif af_staged "$ftype"; then
            type_index=2
        elif af_modified "$ftype"; then
            type_index=1
        elif af_clean "$ftype"; then
            type_index=0
        else
            read -n1 -p "Unexpected type value of '$ftype'"
        fi

        if [ "$type_index" -ge 0 ] && [ "${PGM_FILTERS[$type_index]}" -ne 0 ]; then
            af_output+=( "$gfile" )
        fi
    done
}

###########################
###   BOUND FUNCTIONS   ###
###########################

exec_help()
{
    local eh_keyp
    pwb_keybinder help KBINDINGS -v eh_keyp

    shift
    exec_line "$eh_keyp" "$@"
    local -i ecode="$?"
    printf $'\eH\e[2J'
    pwb print_all "$3"

    if [[ "$eh_keyp" == 'q' ]] || [ "$ecode" -ne 0 ]; then
        return 1
    fi
}

exec_template()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"

    # Restore screen
    printf $'\eH\e[2J'
    pwb print_all "$3"
}

exec_add()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"

    if [[ "${status:0:1}" == "${status:1:1}" ]]; then
        if git add "$name"; then
            refresh_line_from_git_status "$name" "$2" "$3" "$4"
        fi
    fi
}

exec_stage()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"
    if [[ "$status" =~ ^.(M|T|A|D|R|C)$ ]]; then
        if git add "$name"; then
            refresh_line_from_git_status "$name" "$2" "$3" "$4"
        else
            read -n1 -p "Failed to stage the file"
        fi
    fi

    return 0
}

exec_unstage()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"

    if [[ "$status" =~ ^(M|T|A|D|R|C).$ ]]; then
        if git restore --staged "$name"; then
            refresh_line_from_git_status "$name" "$2" "$3" "$4"
        else
            read -n1 -p "Some kind of error restoring '$name'"
        fi
    fi

    return 0
}

exec_commit_name()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"

    if ! [[ "${status:0:1}" == "${status:1:1}" ]]; then
        declare -a ecn_lines=( $'Pending \e[32;1mCommit Selected File\e[39;22m Action' "" )
        printf -v ecn_lines["${#ecn_lines[*]}"] \
               $'About to commit \e[32;1m%s\e[39;22m' "$name"
        printf -v ecn_lines["${#ecn_lines[*]}"] \
               $'Command: \e[34;1m%s\e[39;22m' "git commit $name"

        if confirm_dialog ecn_lines "$exec_phandle"; then
            if git commit "$name"; then
                refresh_line_from_git_status "$name" "$2" "$3" "$4"
            fi
        fi
        printf $'\e[J\e2J'
        pwb print_all "$exec_phandle"
    fi

    return 0
}

exec_commit_staged()
{
    local exec_phandle="$4"

    local -a ecs_staged
    local -i ecs_refresh=0

    if get_staged_indexes ecs_staged ecs_refresh; then
        declare -a ecn_lines=( $'Pending \e[32;1mCommit Staged Files\e[39;22m Action' "" )
        printf -v ecn_lines["${#ecn_lines[*]}"] \
               $'Command: \e[34;1m%s\e[39;22m' "git commit"

        if confirm_dialog ecn_lines "$exec_phandle"; then
            if git commit; then
                if [ "$ecs_refresh" -ne 0 ]; then
                    SP_REFRESH_FLAG=1
                    return 1
                else
                    refresh_lines_by_index_array ecs_staged "$exec_phandle"
                fi
            fi
        fi
        printf $'\e[J\e2J'
        pwb print_all "$exec_phandle"
    fi

    return 0
}



exec_filter()
{
    local exec_phandle="$4"
    local -a exec_row

    local -a head_lines=(
        "Enable sets of files to include in your view."
        ""
    )

    local -a new_filters

    local -a sel_args=(
        -m
        -h head_lines
        -jc
        -s PGM_FILTERS
        -t flags
        -v new_filters
    )
    if pwb_selector PGM_FILTER_LABELS "${sel_args[@]}"; then
        PGM_FILTERS=( "${new_filters[@]}" )
        SP_REFRESH_FLAG=1
    else
        # Restore screen
        printf $'\eH\e[2J'
        pwb print_all "$3"
    fi

    return 1
}



exec_checkout_file()
{
    local -n exec_data="$3"
    local exec_phandle="$4"
    local -a exec_row
    IFS="$DELIM" read -r -a exec_row <<< "${exec_data[$2]}"
    local name="${exec_row[0]}"
    local status="${exec_row[1]}"

    if ! [[ "${status:0:1}" == "${status:1:1}" ]]; then
        declare -a ecn_lines=( $'Pending \e[32;1mUndo (Checkout) Selected File\e[39;22m Action' "" )
        printf -v ecn_lines["${#ecn_lines[*]}"] \
               $'About to undo changes to \e[32;1m%s\e[39;22m' "$name"
        printf -v ecn_lines["${#ecn_lines[*]}"] \
               $'Command: \e[34;1m%s\e[39;22m' "git checkout $name"

        if confirm_dialog ecn_lines "$exec_phandle"; then
            if git checkout "$name"; then
                refresh_line_from_git_status "$name" "$2" "$3" "$4"
            else
                read -n1 -p "Oops, failed to checkout '$name'"
                return 1
            fi
        fi
        printf $'\e[J\e2J'
        pwb print_all "$exec_phandle"
    fi

    return 0
}

#########################
###   PWB CALLBACKS   ###
#########################

print_line()
{
    local -n pl_dsource="$2"
    local -a pl_row
    IFS="$DELIM" read -r -a pl_row <<< "${pl_dsource[$1]}"

    local status="${pl_row[1]}"

    local color="39;22"
    if [[ "$status" == "  " ]]; then
        color=38\;5\;46   # green for clean
    elif [[ "$status" =~ \?\? ]]; then
        color=38\;5\;243  # dark grey for untracked file
    elif [[ "$status" =~ \!\! ]]; then
        color=38\;5\;252  # light grey for ignored file
    elif [[ "$status" =~ ^(M|T|A|D|R|C)[[:space:]]$ ]]; then
        color=38\;5\;33   # blue for modified, staged
    elif [[ "$status" =~ ^.(M|T|A|D|R|C)$ ]]; then
        color=38\;5\;208  # orange for modified, unstaged
    fi

    printf $'\e[%sm' "$color"
    printf "%-*.*s" "$3" "$3" "${pl_row[0]}"
    printf $'\e[39;22m'
}

# Choice of two left-print functions, used according
# to whether or not a scroll-bar is called for:
noop_print_left() { :; }
scrollbar_print_left()
{
    local -i index="$1"
    local -i chars_count="$3"
    local pl_handle="$5"

    local -i left=$(( chars_count - 2 ))

    local -i rows top
    pwb get_data_count "$pl_handle" -v rows
    pwb get_top_row "$pl_handle" -v top

    local -a scrollbar_args=(
        -s "$rows"
        -t "$top"
        -v "${SP_REGIONS[LM_LINES]}"
    )

    local -a pl_scrollbar
    pwb_get_scroll_bar pl_scrollbar "${scrollbar_args[@]}"

    for block in "${pl_scrollbar[@]}"; do
        printf $'\e[%dG%s\e[1D\e[1E' "$left" "$block"
    done
}

print_top()
{
    local -n pt_dsource="$2"
    local -a pt_row
    IFS="$DELIM" read -r -a pt_row <<< "${pt_dsource[$1]}"

    local -a pt_lines=( "PWB GIT MANAGER" )
    printf -v pt_lines[${#pt_lines[*]}] $'Branch \e[34;1m%s\e[39;22m' "$SP_BRANCH_NAME"
    add_status_analysis_to_header pt_lines "${pt_row[1]}"
    pt_lines["${#pt_lines[*]}"]="Status is '${pt_row[1]}'"

    printf $'\e[48;5;235m'
    pwb_print_array pt_lines "${ARGS_PRINT_TOP[@]}"
    printf $'\e[49m'
}

print_bottom()
{
    local -i index="$1"
    local -i total="${#SP_DATA[*]}"
    local -a pb_lines
    printf -v pb_lines[0] $'Record \e[33;1m%d\e[39;22m out of \e[33;1m%d\e[39;22m' \
           $(( index+1 )) "$total"
    printf -v pb_lines["${#pb_lines[*]}"] "Press F1 for help"

    pwb_print_array pb_lines "${ARGS_PRINT_BOTTOM[@]}"
}


exec_line()
{
    local keyp="$1"
    local el_handle="$4"

    local -i ecode=0
    local el_func
    if pwb_keybinder func KEYFUNCS -v el_func -k "$keyp"; then
        "$el_func" "$@"
        ecode="$?"
        # printf $'\e[H\e[2J'
        # pwb print_all "$el_handle"
    fi

    return "$ecode"
}


###################################
###   INSTANCE PREP FUNCTIONS   ###
###################################

get_content_width()
{
    local -n gcw_wide="$1"
    local -n gcw_array="$2"

    local -i cur_wide
    gcw_wide=0
    for line in "${gcw_array[@]}"; do
        # Subtract delimiter and 2-character status value:
        cur_wide=$(( ${#line} - 3 ))

        (( gcw_wide = ( cur_wide >gcw_wide ? cur_wide : gcw_wide ) ))
    done
}

set_instance_margins()
{
    local sim_handle="$1"
    local sim_data="$2"

    local -i data_width
    get_content_width data_width "$sim_data"

    local -A sim_dims
    pwb get_dimensions -A sim_dims

    local -i non_content=$(( sim_dims[screen_cols] - data_width ))
    local -i left right
    (( right = non_content / 2 ))
    (( left = right + (non_content % 2) ))

    local -a sim_margins=( 5 "$right" 2 "$left" )

    pwb set_margins "$sim_handle" "${sim_margins[@]}"
}

# Break out the global-array-setting code from start_program()
set_print_args()
{
    local -n spa_top="$1"
    local -n spa_bottom="$2"
    local -n spa_regions="$3"

    spa_top=(
        -t "${spa_regions[TM_TOP]}"
        -c "${spa_regions[TM_LINES]}"
        -l "${spa_regions[SC_LEFT]}"
        -w "${spa_regions[SC_WIDE]}"
    )

    spa_bottom=(
        -t "${spa_regions[BM_TOP]}"
        -c "${spa_regions[BM_LINES]}"
        -l "${spa_regions[SC_LEFT]}"
        -w "${spa_regions[SC_WIDE]}"
    )

    spa_left=(
        -t "${spa_regions[LM_TOP]}"
        -c "${spa_regions[LM_LINES]}"
        -l "${spa_regions[LM_LEFT]}"
        -w "${spa_regions[LM_WIDE]}"
    )
}

filter_include_all()
{
    for filter in "${PGM_FILTERS[@]}"; do
        if [ "$filter" -eq 0 ]; then
            return 1
        fi
    done
    return 0
}

start_program()
{
    local SP_FILTER=""
    local -a FILTER_TABLE

    local SP_BRANCH_NAME
    get_branch_name SP_BRANCH_NAME

    local -a SP_FULL_DATA
    local -i SP_REFRESH_FLAG=0

    while :; do
        # Prepare Static Data
        SP_FULL_DATA=()
        get_context_data SP_FULL_DATA
        SP_REFRESH_FLAG=0

        local arr_name=SP_FULL_DATA

        while [ "$SP_REFRESH_FLAG" -eq 0 ]; do
            if filter_include_all; then
                arr_name="SP_FULL_DATA"
            else
                FILTER_TABLE=()
                apply_filters FILTER_TABLE SP_FULL_DATA
                arr_name="FILTER_TABLE"
            fi

            local -n SP_DATA="$arr_name"
            local -i SP_DATA_COUNT="${#SP_DATA[*]}"

            local p_print_left=scrollbar_print_left
            print_left() { "$p_print_left" "$@"; }

            if [ "$SP_DATA_COUNT" -eq 0 ]; then
                local -a no_data=(
                    "Error: no files using the current filter."
                    "Adjust the filter to show more records."
                )
                pwb_conduct_dialog no_data
                exit
            else
                local -a pwb_args=(
                    SP_DATA
                    "$SP_DATA_COUNT"
                    print_line
                    -e exec_line
                    -b print_bottom
                    -t print_top
                    -l print_left
                )

                local SP_HANDLE
                pwb declare SP_HANDLE "${pwb_args[@]}"
                pwb_exit_on_error

                set_instance_margins SP_HANDLE SP_DATA

                local -A SP_REGIONS
                pwb_get_regions SP_REGIONS SP_HANDLE

                # Globally set array-printing args
                local -a ARGS_PRINT_TOP ARGS_PRINT_BOTTOM
                set_print_args ARGS_PRINT_TOP ARGS_PRINT_BOTTOM SP_REGIONS

                # Install print_left according to scrollbar need:
                if [ "$SP_DATA_COUNT" -gt "${SP_REGIONS[CO_LINES]}" ]; then
                    p_print_left=scrollbar_print_left
                else
                    p_print_left=noop_print_left
                fi

                local ending_keyp
                pwb start SP_HANDLE -a KEYMAP -k ending_keyp
                pwb_exit_on_error

                if [[ "$ending_keyp" =~ ^Q|q$ ]]; then
                    exit 0
                fi
            fi
        done
    done
}

#########################
###   MISCELLANEOUS   ###
#########################

# Update array data and, if visible, the affected content line.
refresh_line_from_git_status()
{
    local rlfg_name="$1"

    local -i rlfg_index="$2"
    local rlfg_dhandle="$3"
    local rlfg_phandle="$4"

    local new_rec
    local status=$( git status -s "$rlfg_name" )
    if [ -n "$status" ]; then
        if ! record_from_status_line new_rec "$status"; then
            read -n1 -p "Unexpected failure to get status record."
        fi
    else
        new_rec="${rlfg_name}${DELIM}  "
    fi

    local -n rlfg_array="$rlfg_dhandle"
    rlfg_array["$rlfg_index"]="$new_rec"
    pwb print_row "$rlfg_phandle" "$rlfg_index"
}

refresh_lines_by_index_array()
{
    local -n rlbia_array="$1"
    local flbia_phandle="$2"

    local IFS="$DELIM"
    local -a row
    local -i index
    for index in "${rlbia_array[@]}"; do
        read -r -a row <<< "${SP_FULL_DATA[$index]}"
        refresh_line_from_git_status "${row[0]}" "$index" SP_FULL_DATA "$flbia_phandle"
    done
}

get_branch_name()
{
    local -n gbn_name="$1"
    while read -r; do
        if [[ "${REPLY:0:2}" == '* ' ]]; then
            gbn_name="${REPLY:2}"
            break
        fi
    done < <( git branch )
}

get_status_type()
{
    local -n gst_type="$1"
    local gst_char="$2"
    case "$gst_char" in
        M) gst_type="modified" ;;
        T) gst_type="file type changed" ;;
        A) gst_type="added" ;;
        D) gst_type="deleted" ;;
        R) gst_type="renamed" ;;
        C) gst_type="copied" ;;
        U) gst_type="updated unmerged" ;;
        *) gst_type="n/a" ;;
    esac
}

get_staged_indexes()
{
    local -n gsi_indexes="$1"

    local -n gsi_refresh_required="$2"
    gsi_refresh_required=0

    local -a gsi_row
    local raw_row
    local staging_char
    local IFS="$DELIM"
    local -i index=0
    for raw_row in "${SP_FULL_DATA[@]}"; do
        IFS="$DELIM" read -r -a gsi_row <<< "$raw_row"
        staging_char="${gsi_row[1]:0:1}"
        if ! [[ "$staging_char" =~ ^!|\?|\ $ ]]; then
            gsi_indexes+=( "$index" )
            if ! [[ "$staging_char" =~ ^R|A|D$ ]]; then
                (( ++gsi_refresh_required ))
            fi
        fi
        (( ++index ))
    done

    [ "${#gsi_indexes[*]}" -gt 0 ]
}

# From info found in the two-character XY status string,
# add descriptive lines to an existing array.
add_status_analysis_to_header()
{
    local -n gsa_report="$1"
    local gsa_status="$2"

    if [[ "$gsa_status" == "  " ]]; then
        gsa_report+=( "The file is up-to-date." )
    elif [[ "$gsa_status" == "!!" ]]; then
        gsa_report+=( "The file is ignored with .gitignore." )
    elif [[ "$gsa_status" == "??" ]]; then
        gsa_report+=( "The file is not being tracked by Git." )
    else
        local staging_char="${gsa_status:0:1}"
        local working_char="${gsa_status:1:1}"

        if [[ "$staging_char" == " " ]]; then
            gsa_report+=( "File is not staged for commit." )
        else
            local staging_status
            get_status_type staging_status "$staging_char"

            printf -v gsa_report["${#gsa_report[*]}"] \
                   $'The \e[34;1m%s\e[39;22m file is staged for commit type.' "$staging_statuos"
        fi

        if [[ "$working_char" == " " ]]; then
            gsa_report+=( "File has not changed." )
        else
            local working_status
            get_status_type working_status "$working_char"

            printf -v gsa_report["${#gsa_report[*]}"] \
                   $'The \e[34;1m%s\e[39;22m file is not yet staged.' "$working_status"
        fi
    fi
}

set_filter()
{
    SP_FILTER="$1"
}

# Return true(0)/false(!0) user response to content in an array of lines.
confirm_dialog()
{
    local -n cd_lines="$1"
    local cd_pwb_handle="$2"
    cd_lines+=( "Type 'y' to confirm; type 'n' or ESC to abort." )
    local -a allowed_keys=( y Y n N $'\e' )
    local keyp

    pwb_conduct_dialog "$1" "$2" -a allowed_keys -r keyp

    [[ "yY" =~ "$keyp" ]]
}

exit_trap() { printf $'\e[H\e[2J'; pwb restore; cd "$OG_DIR"; }

############################
###   EXECUTION BEGINS   ###
############################

declare DELIM=$'|'

enable pwb

declare -a PSOURCES=(
    pwb_exit_on_error
    pwb_get_regions
    pwb_conduct_dialog
    pwb_print_array
    pwb_get_scroll_bar
    pwb_keybinder
    pwb_run_menu
    pwb_selector
)
source <( pwb_sources "${PSOURCES[@]}" )

declare -a KBINDINGS=(
    "key_f1"  exec_help          "Show help"
    a         exec_add           "Add file to work tree"
    c         exec_commit_name   "Commit selected file"
    C         exec_commit_staged "Commit staged files"
    f         exec_filter        "Filter files by type"
    s         exec_stage         "Stage file"
    u         exec_unstage       "Unstage file"
    U         exec_checkout_file "Undo file changes (checkout)"
)

declare -a PGM_FILTER_LABELS=(
    Clean
    Modified
    Staged
    Ignored
    Untracked
)

declare -a PGM_FILTERS=(
    1       # show clean
    1       # show modified
    1       # show staged
    1       # show_ignored
    1       # show_untracked
)

declare KEYMAP
declare -a KEYFUNCS
pwb_keybinder prep KBINDINGS -v KEYMAP -f KEYFUNCS

trap exit_trap EXIT SIGINT SIGABRT
pwb init

declare OG_DIR="$PWD"

declare -a DIR_STEPS=( "$PWD" )

start_program


cd "$OG_DIR"
