#!/usr/bin/env bash

##########################
###   DATA FUNCTIONS   ###
##########################

get_context_data()
{
    local -n gcd_return="$1"

    # Prevent literal '*' element for empty directory:
    shopt -s nullglob
    local -a gcd_files=( * )
    shopt -u nullglob

    for fname in "${gcd_files[@]}"; do
        if [ -d "$fname" ]; then
            gcd_return+=( "*$fname" )
        else
            gcd_return+=( "$fname" )
        fi
    done
}

###########################
###   BOUND FUNCTIONS   ###
###########################

exec_help()
{
    local eh_keyp
    pwb_keybinder help KBINDINGS -v eh_keyp

    shift
    exec_line "$eh_keyp" "$@"
    local -i ecode="$?"
    if [[ "$eh_keyp" == 'q' ]] || [ "$ecode" -ne 0 ]; then
        return 1
    fi
}

exec_return()
{
    return 1
}

exec_open()
{
    local -n eo_array="$3"
    local eo_line="${eo_array[$2]}"

    if [[ "${eo_line:0:1}" == \* ]]; then
        eo_line="${eo_line:1}"
        DIR_STEPS+=( "$eo_line" )
        local EO_OG_DIR="$PWD"
        cd "$eo_line"
        printf $'\e[H\e[2J'
        start_instance
        DIR_STEPS=( "${DIR_STEPS[@]:0:${#DIR_STEPS[*]}-1}" )
        cd "$EO_OG_DIR"
    fi
    return 0
}


#########################
###   PWB CALLBACKS   ###
#########################

print_line()
{
    local -n pl_dsource="$2"
    local pl_row="${pl_dsource[$1]}"
    if [[ "${pl_row:0:1}" == \* ]]; then
        printf $'\e[34;1m'
        printf "%-*.*s" "$3" "$3" "${pl_row:1}"
        printf $'\e[39;22m'
    else
        printf "%-*.*s" "$3" "$3" "$pl_row"
    fi
}

noop_print_left() { :; }
print_left()
{
    local -i index="$1"
    local pl_handle="$5"

    local limit_args=(
        -t "${SI_REGIONS[LM_TOP]}"
        -c "${SI_REGIONS[LM_LINES]}"
        -l "${SI_REGIONS[LM_LEFT]}"
        -w "${SI_REGIONS[LM_WIDE]}"
    )

    local -i left=$(( SI_REGIONS[LM_WIDE] - 2 ))

    local -i rows top
    pwb get_data_count "$pl_handle" -v rows
    pwb get_top_row "$pl_handle" -v top

    local -a scrollbar_args=(
        -s "$rows"
        -t "$top"
        -v "${SI_REGIONS[LM_LINES]}"
    )

    local -a pl_scrollbar
    pwb_get_scroll_bar pl_scrollbar "${scrollbar_args[@]}"

    for block in "${pl_scrollbar[@]}"; do
        printf $'\e[%dG%s\e[1D\e[1E' "$left" "$block"
    done
}

print_top()
{
    local limit_args=(
        -t "${SI_REGIONS[TM_TOP]}"
        -c "${SI_REGIONS[TM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -a pt_lines=( "PWB TEMPLATE BASE" )

    local IFS="/"
    printf -v pt_lines["${#pt_lines[*]}"] "%s" "${DIR_STEPS[*]}"
    printf -v pt_lines["${#pt_lines[*]}"] "Press F1 for help"

    pwb_print_array pt_lines "${limit_args[@]}"
}

print_bottom()
{
    local limit_args=(
        -t "${SI_REGIONS[BM_TOP]}"
        -c "${SI_REGIONS[BM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -i index="$1"
    local -i total="${#SI_DATA[*]}"
    local -a lines
    printf -v lines[0] $'Record \e[33;1m%d\e[39;22m out of \e[33;1m%d\e[39;22m' \
           $(( index+1 )) "$total"

    pwb_print_array lines "${limit_args[@]}"
}


exec_line()
{
    local keyp="$1"
    local el_handle="$4"

    local -i ecode=0
    local el_func
    if pwb_keybinder func KEYFUNCS -v el_func -k "$keyp"; then
        "$el_func" "$@"
        ecode="$?"
        printf $'\e[H\e[2J'
        pwb print_all "$el_handle"
    fi

    return "$ecode"
}


###################################
###   INSTANCE PREP FUNCTIONS   ###
###################################

get_content_width()
{
    local -n gcw_wide="$1"
    local -n gcw_array="$2"

    local -i cur_wide
    gcw_wide=0
    for line in "${gcw_array[@]}"; do
        cur_wide="${#line}"
        (( gcw_wide = ( cur_wide >gcw_wide ? cur_wide : gcw_wide ) ))
    done
}

set_instance_margins()
{
    local sim_handle="$1"
    local sim_data="$2"

    local -i data_width
    get_content_width data_width "$sim_data"

    local -A sim_dims
    pwb get_dimensions -A sim_dims

    local -i non_content=$(( sim_dims[screen_cols] - data_width ))
    local -i left right
    (( right = non_content / 2 ))
    (( left = right + (non_content % 2) ))

    local -a sim_margins=( 5 "$right" 2 "$left" )

    pwb set_margins "$sim_handle" "${sim_margins[@]}"
}

start_instance()
{
    # Prepare Data
    local -a SI_DATA
    get_context_data SI_DATA
    local -i SI_DATA_COUNT="${#SI_DATA[*]}"

    if [ "$SI_DATA_COUNT" -eq 0 ]; then
        declare -a si_lines
        printf -v si_lines["${#si_lines[*]}"] \
               $'Directory \e[32;1m%s\e[39;22m is empty' "$PWD"
        si_lines+=(
            ""
            "Press any key to return."
        )
        pwb_conduct_dialog si_lines
    else
        local print_left_func=print_left
        p_print_left() { "$print_left_func" "$@"; }

        # Create Handle
        local -a declare_args=(
            SI_DATA
            "$SI_DATA_COUNT"
            print_line
            -e exec_line
            -b print_bottom
            -t print_top
            -l p_print_left
        )

        local SI_HANDLE
        pwb declare SI_HANDLE "${declare_args[@]}"
        pwb_exit_on_error

        # Prepare Handle
        set_instance_margins SI_HANDLE SI_DATA

        # With margins established, get instance-global regions
        local -A SI_REGIONS
        pwb_get_regions SI_REGIONS SI_HANDLE

        # Use do-nothing function for scrollbar not needed:
        if (( SI_DATA_COUNT <= SI_REGIONS[CO_LINES] )); then
            print_left_func=noop_print_left
        fi

        local ending_keyp
        declare -a start_args=(
            -a KEYMAP
            -k ending_keyp
        )

        pwb start SI_HANDLE "${start_args[@]}"
        pwb_exit_on_error

        if [[ "$ending_keyp" == 'q' ]]; then
            exit 0
        fi
    fi
}

#########################
###   MISCELLANEOUS   ###
#########################

exit_trap() { printf $'\e[H\e[2J'; pwb restore; }

############################
###   EXECUTION BEGINS   ###
############################

enable pwb

declare -a PSOURCES=(
    pwb_exit_on_error
    pwb_get_regions
    pwb_conduct_dialog
    pwb_print_array
    pwb_get_scroll_bar
    pwb_keybinder
)
source <( pwb_sources "${PSOURCES[@]}" )

declare -a KBINDINGS=(
    "key_f1"     exec_help   "Show help"
    "key_right"  exec_open   "Enter directory"
    "key_left"   exec_return "Exit directory"
    "key_escape" exec_return "Return"
)

declare KEYMAP
declare -a KEYFUNCS
pwb_keybinder prep KBINDINGS -v KEYMAP -f KEYFUNCS

trap exit_trap EXIT SIGINT SIGABRT
pwb init

declare OG_DIR="$PWD"
cd /

declare -a DIR_STEPS=( "$PWD" )

start_instance

cd "$OG_DIR"
