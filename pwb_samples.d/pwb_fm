#!/usr/bin/env bash

##########################
###   DATA FUNCTIONS   ###
##########################

get_context_data()
{
    local -n gcd_return="$1"
    gcd_return=()

    local -a gcd_files
    while read -r; do
        gcd_files+=( "$REPLY" )
    done < <( ls -1a )

    if [ "${#gcd_files[*]}" -gt 0 ]; then
        local gcd_format
        make_stat_format gcd_format STAT_ATOMS

        local IFS="$DELIM"
        local -a gcd_row
        local -a gcd_type
        local -a gcd_flags
        local gcd_filename

        while read -r; do
            gcd_row=( $REPLY )
            gcd_filename="${gcd_row[0]}"
            get_file_flags gcd_flags  "$gcd_filename"

            IFS="$FDELIM"
            gcd_row=( "${gcd_flags[*]}" "$gcd_filename" "${gcd_row[@]:1}" )
            IFS="$DELIM"

            gcd_return+=( "${gcd_row[*]}" )
        done < <( stat -c "$gcd_format" "${gcd_files[@]}" )
    fi
}

remove_context_row()
{
    local -i rcr_index="$1"
    local -i rcr_total="${#SI_DATA[*]}"

    local -a rcr_left
    local -a rcr_right

    if (( rcr_index > 0 )); then
        rcr_left=( "${SI_DATA[@]:0:$rcr_index}" )
        # Move up a line before removing it
        pwb trigger SI_HANDLE 2
    fi
    if (( rcr_index < rcr_total )); then
        rcr_right=( "${SI_DATA[@]:$(( rcr_index+1 ))}" )
    fi

    SI_DATA=( "${rcr_left[@]}" "${rcr_right[@]}" )
    SI_DATA_COUNT="${#SI_DATA[*]}"
    pwb set_data_count SI_HANDLE "$SI_DATA_COUNT"
    pwb_exit_on_error
}

find_context_row()
{
    local -n fcr_return="$1"
    local fcr_search="$2"
    local -i slen="${#fcr_search}"
    local -a fcr_row

    local -i fcr_index=0
    for raw_row in "${SI_DATA[@]}"; do
        IFS="$DELIM" read -r -a fcr_row <<< "$raw_row"
        local fcr_name="${fcr_row[1]}"
        local fcr_len="${#fcr_name}"

        if [[ "${fcr_name:0:$slen}" == "$fcr_search" ]]; then
            fcr_return="$fcr_index"
            return 0
        elif [[ "${fcr_name:0:$slen}" > "$fcr_search" ]]; then
            break
        fi

        (( ++fcr_index ))
    done

    return 1
}


################################
###   STAT_ATOMS FUNCTIONS   ###
################################

make_stat_format()
{
    local -n msf_return="$1"
    local -n mfs_atoms="$2"

    local -a mfs_parts
    local -a row
    local -i count=0

    for atom in "${mfs_atoms[@]}"; do
        if [ "$count" -eq 0 ]; then
            mfs_parts+=( "%$atom" )
            (( ++count ))
        else
            count=0
        fi
    done

    local IFS="$DELIM"
    msf_return="${mfs_parts[*]}"
}

get_file_flags()
{
    local -n gff_return="$1"
    local gff_file="$2"
    local -a gff_row
    local gff_color=0

    gff_return=()

    for el in "${FILE_TYPES[@]}"; do
        gff_row+=( "$el" )
        if [ "${#gff_row[*]}" -eq 3 ]; then
            if [ "${gff_row[0]}" "$gff_file" ]; then
                gff_return+=( 1 )
                gff_color="${gff_row[2]}"
            else
                gff_return+=( 0 )
            fi
            gff_row=()
        fi
    done

    gff_return+=( "$gff_color" )
}

# Update FILE_TYPES array with colors according to 'dircolors' entry.
assign_file_type_colors()
{
    local -n aftc_colors="$1"

    local aftc_dircolors
    if [ -n "$LS_COLORS" ]; then
        aftc_dircolors="$LS_COLORS"
    else
        local raw_colors=$( dircolors -c )
        if [[ "$raw_colors" =~ ^[^\']+\'([^\']+)$ ]]; then
            aftc_dircolors="${BASH_REMATCH[0]}"
        fi
    fi

    local -a new_colors
    local -a aftc_row

    for el in "${aftc_colors[@]}"; do
        aftc_row+=( "$el" )
        if [ "${#aftc_row[*]}" -eq 3 ]; then
            local regex="${aftc_row[1]}=([^:]+)"
            if [[ "$aftc_dircolors" =~ $regex ]]; then
                aftc_row[2]="${BASH_REMATCH[1]}"
            else
                aftc_row[2]="$el"
            fi
            new_colors+=( "${aftc_row[@]}" )
            aftc_row=()
        fi
    done

    aftc_colors=( "${new_colors[@]}" )
}

###########################
###   BOUND FUNCTIONS   ###
###########################

mime_type_not_blacklisted()
{
    local regex
    for regex in "${MIME_TYPE_BLACKLIST[@]}"; do
        if [[ "$1" =~ $regex ]]; then
            return 1
        fi
    done
    return 0
}

mime_app_not_blacklisted()
{
    local regex
    for regex in "${MIME_APP_BLACKLIST[@]}"; do
        printf $'Comparing app \e[34;1m%s\e[39;22m to regex \e[34;1m%s\e[39;22m\n' \
               "$1" "$regex"
        if [[ "$1" =~ $regex ]]; then
            return 1
        fi
    done
    return 0
}


# enter directory for exec_enter AND exec_default
exec_name_enter()
{
    local ene_name="$1"
    DIR_STEPS+=( "$ene_name" )
    local ENE_OG_DIR="$PWD"
    cd "$ene_name"
    printf $'\e[H\e[2J'
    start_instance
    DIR_STEPS=( "${DIR_STEPS[@]:0:${#DIR_STEPS[*]}-1}" )
    cd "$ENE_OG_DIR"
}

# execute name for exec_enter AND exec_default
exec_name_execute()
{
    local ene_name="$1"
    printf $'\e[H\e[2J'
    "$ene_name"
}

get_launch_args()
{
    local -n gla_args="$1"
    local gla_file="$2"

    gla_args=()

    if is_man "$gla_file"; then
        gla_args=( man -l "$gla_file" )
    elif is_markdown "$gla_file"; then
        gla_args=( thorium-browser --new-window "$gla_file" )
    else
        local mtype mapp
        if mtype=$( xdg-mime query filetype "$gla_file" ); then
            if mime_type_not_blacklisted "$mtype"; then
                if mapp=$( xdg-mime query default "$mtype" ); then
                    if [ -n "$mapp" ] && mime_app_not_blacklisted "$mapp"; then
                        gla_args=( gtk-launch "$mapp" "$gla_file" )
                    fi
                else
                    read -n1 -p "Unknown application for '$gla_file' mimetype '$mtype'"
                fi
            fi
        else
            read -n1 -p "Unknown mime type for file '$gla_file'"
        fi
    fi

    # return value from running test:
    [ "${#gla_args[*]}" -gt 1 ]
}


exec_template()
{
    local -n et_array="$3"
    local -a et_row
    IFS="$DELIM" read -r -a et_row <<< "${et_array[$2]}"
    local et_type="${et_row[0]}"
    local et_name="${et_row[1]}"
}

exec_help()
{
    local eh_keyp
    pwb_keybinder help KBINDINGS -v eh_keyp

    shift
    exec_line "$eh_keyp" "$@"
    local -i ecode="$?"
    if [[ "$eh_keyp" == 'q' ]] || [ "$ecode" -ne 0 ]; then
        return 1
    fi
}

exec_return()
{
    return 1
}

exec_delete()
{
    local -n et_array="$3"
    local -a et_row
    IFS="$DELIM" read -r -a et_row <<< "${et_array[$2]}"
    local et_type="${et_row[0]}"
    local et_name="${et_row[1]}"

    if ! is_directory "$et_type"; then
        if confirm_action "Delete file '$et_name'"; then
            rm "$et_name"
            remove_context_row "$2"
        fi
    fi
}

exec_enter()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"

    if is_directory "${ee_row[0]}"; then
        exec_name_enter "${ee_row[1]}"
    fi

    return 0
}

exec_edit()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"
    local ee_type="${ee_row[0]}"

    if ! is_directory "$ee_type"; then
        local -a cur_margins
        pwb_get_margins cur_margins SI_HANDLE
        pwb set_margins SI_HANDLE 0

        local ee_editor="${EDITOR:-nano}"
        "$ee_editor" "${ee_row[1]}"

        pwb set_margins SI_HANDLE "${cur_margins[@]}"
    fi

    return 0
}

exec_view()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"
    local ee_type="${ee_row[0]}"

    if ! is_directory "$ee_type"; then
        local -a cur_margins
        pwb_get_margins cur_margins SI_HANDLE
        pwb set_margins SI_HANDLE 0

        "${VIEW_CALL_ARGS[@]}" "${ee_row[1]}"

        pwb set_margins SI_HANDLE "${cur_margins[@]}"
    fi

    return 0
}

exec_execute()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"
    local ee_type="${ee_row[0]}"

    if is_executable "$ee_type"; then
        exec_name_execute "${ee_row[1]}"
    fi
}

exec_launch()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"
    local ee_type="${ee_row[0]}"

    local -a ee_launch_args

    if get_launch_args ee_launch_args "${ee_row[1]}"; then
        local -a cur_margins
        pwb_get_margins cur_margins SI_HANDLE
        pwb set_margins SI_HANDLE 0
        "${ee_launch_args[@]}"
        pwb set_margins SI_HANDLE "${cur_margins[@]}"
    fi
}

exec_default()
{
    local -n ed_array="$3"
    local -a ed_row
    IFS="$DELIM" read -r -a ed_row <<< "${ed_array[$2]}"
    local ed_type="${ed_row[0]}"
    local ed_name="${ed_row[1]}"

    if is_directory "$ed_type"; then
        exec_name_enter "$ed_name"
    elif is_executable "$ed_type"; then
        exec_name_execute "$ed_name"
    else
        local -a ee_launch_args
        if get_launch_args ee_launch_args "$ed_name"; then
            local -a cur_margins
            pwb_get_margins cur_margins SI_HANDLE
            pwb set_margins SI_HANDLE 0
            "${ee_launch_args[@]}"
            pwb set_margins SI_HANDLE "${cur_margins[@]}"
        fi
    fi
}

exec_search()
{
    # # Save parameters to restore is cancelling the search:
    local -i old_top old_focus
    pwb get_top_row SI_HANDLE -v old_top
    pwb get_focus_row SI_HANDLE -v old_focus

    local es_search
    local es_keyp
    local -i search_len

    local es_lines=(
        $'\e[44m        Search        \e[49m'
        # "old_top: $old_top, old_focus: $old_focus"
        ""
    )

    while :; do
        printf -v es_lines[2] $'%s\e[5m\u2581\e[25m' "$es_search"
        pwb_print_message es_lines
        search_len="${#es_search}"

        pwb get_keystroke -v es_keyp
        if is_typeable "$es_keyp"; then
            es_search="${es_search}${es_keyp}"
        elif [[ "$es_keyp" == $'\c?' ]]; then
            if (( search_len > 0 )); then
                es_search="${es_search:0: -1}"
            fi
        elif [[ "$es_keyp" == $'\cm' ]]; then
            break
        elif [[ "$es_keyp" == $'\e' ]]; then
            pwb set_focus_row SI_HANDLE -f "$old_focus" -t "$old_top"
            break
        fi

        local -i es_index=-1
        if find_context_row es_index "$es_search"; then
            # local -a es_row
            # IFS="$DELIM" read -r -a es_row <<< "${SI_DATA[$es_index]}"
            # printf $'%4d: %*.*s' "$es_index" 40 40 "${es_row[1]}"
            pwb set_focus_row SI_HANDLE -f "$es_index"
        fi
    done
}

#########################
###   PWB CALLBACKS   ###
#########################

print_line()
{
    local -n pl_dsource="$2"
    local -a pl_row
    IFS="$DELIM" read -r -a pl_row <<< "${pl_dsource[$1]}"

    # First element is a compressed array of flags, the last
    # of which is the color to use to display the name:
    local col="${pl_row[0]}"
    col="${col##*$FDELIM}"
    if [[ "$col" == "0" ]]; then
        printf "%-*.*s" "$3" "$3" "${pl_row[1]}"
    else
        printf $'\e[%sm' "$col"
        printf "%-*.*s" "$3" "$3" "${pl_row[1]}"
        printf $'\e[m'
    fi
}

noop_print_left() { :; }
print_left()
{
    local -i index="$1"
    local pl_handle="$5"

    local limit_args=(
        -t "${SI_REGIONS[LM_TOP]}"
        -c "${SI_REGIONS[LM_LINES]}"
        -l "${SI_REGIONS[LM_LEFT]}"
        -w "${SI_REGIONS[LM_WIDE]}"
    )

    local -i left=$(( SI_REGIONS[LM_WIDE] - 2 ))

    local -i rows top
    pwb get_data_count "$pl_handle" -v rows
    pwb get_top_row "$pl_handle" -v top

    local -a scrollbar_args=(
        -s "$rows"
        -t "$top"
        -v "${SI_REGIONS[LM_LINES]}"
    )

    local -a pl_scrollbar
    pwb_get_scroll_bar pl_scrollbar "${scrollbar_args[@]}"

    for block in "${pl_scrollbar[@]}"; do
        printf $'\e[%dG%s\e[1D\e[1E' "$left" "$block"
    done
}

print_top()
{
    local limit_args=(
        -t "${SI_REGIONS[TM_TOP]}"
        -c "${SI_REGIONS[TM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -a pt_lines=( "PWB TEMPLATE BASE" )

    local IFS="/"
    printf -v pt_lines["${#pt_lines[*]}"] "%s" "${DIR_STEPS[*]}"
    printf -v pt_lines["${#pt_lines[*]}"] "Press F1 for help"

    pwb_print_array pt_lines "${limit_args[@]}"
}

print_bottom()
{
    local limit_args=(
        -t "${SI_REGIONS[BM_TOP]}"
        -c "${SI_REGIONS[BM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -i index="$1"
    local -i total="${#SI_DATA[*]}"
    local -a lines
    printf -v lines[0] $'Record \e[33;1m%d\e[39;22m out of \e[33;1m%d\e[39;22m' \
           $(( index+1 )) "$total"

    pwb_print_array lines "${limit_args[@]}"
}


exec_line()
{
    local keyp="$1"
    local el_handle="$4"

    local -i ecode=0
    local el_func
    if pwb_keybinder func KEYFUNCS -v el_func -k "$keyp"; then
        "$el_func" "$@"
        ecode="$?"
        printf $'\e[H\e[2J'
        pwb print_all "$el_handle"
    fi

    return "$ecode"
}


###################################
###   INSTANCE PREP FUNCTIONS   ###
###################################

get_content_width()
{
    local -n gcw_wide="$1"
    local -n gcw_array="$2"

    local -a cur_row
    local -i cur_wide
    local cur_name
    gcw_wide=0
    for line in "${gcw_array[@]}"; do
        IFS="$DELIM" read -r -a cur_row <<< "$line"
        cur_name="${cur_row[1]}"
        cur_wide="${#cur_name}"
        (( gcw_wide = ( cur_wide >gcw_wide ? cur_wide : gcw_wide ) ))
    done
}

set_instance_margins()
{
    local sim_handle="$1"
    local sim_data="$2"

    local -i data_width
    get_content_width data_width "$sim_data"

    local -A sim_dims
    pwb get_dimensions -A sim_dims

    local -i non_content=$(( sim_dims[screen_cols] - data_width ))
    local -i left right
    (( right = non_content / 2 ))
    (( left = right + (non_content % 2) ))

    local -a sim_margins=( 5 "$right" 2 "$left" )

    pwb set_margins "$sim_handle" "${sim_margins[@]}"
}

start_instance()
{
    # Prepare Data
    local -a SI_DATA
    get_context_data SI_DATA
    local -i SI_DATA_COUNT="${#SI_DATA[*]}"

    if [ "$SI_DATA_COUNT" -eq 0 ]; then
        declare -a si_lines
        printf -v si_lines["${#si_lines[*]}"] \
               $'Directory \e[32;1m%s\e[39;22m is empty' "$PWD"
        si_lines+=(
            ""
            "Press any key to return."
        )
        pwb_conduct_dialog si_lines
    else
        local print_left_func=print_left
        p_print_left() { "$print_left_func" "$@"; }

        # Create Handle
        local -a declare_args=(
            SI_DATA
            "$SI_DATA_COUNT"
            print_line
            -e exec_line
            -b print_bottom
            -t print_top
            -l p_print_left
        )

        local SI_HANDLE
        pwb declare SI_HANDLE "${declare_args[@]}"
        pwb_exit_on_error

        # Prepare Handle
        set_instance_margins SI_HANDLE SI_DATA

        # With margins established, get instance-global regions
        local -A SI_REGIONS
        pwb_get_regions SI_REGIONS SI_HANDLE

        # Use do-nothing function for scrollbar not needed:
        if (( SI_DATA_COUNT <= SI_REGIONS[CO_LINES] )); then
            print_left_func=noop_print_left
        fi

        local ending_keyp
        declare -a start_args=(
            -a KEYMAP
            -k ending_keyp
        )

        while :; do
            pwb start SI_HANDLE "${start_args[@]}"
            pwb_exit_on_error

            if ( [[ "$ending_keyp" == 'q' ]] || [ "${#DIR_STEPS[*]}" -lt 2 ] ); then
                if confirm_action "Leaving application?"; then
                    exit 0
                else
                    continue
                fi
            else
                break
            fi
        done
    fi
}

#########################
###   MISCELLANEOUS   ###
#########################

exit_trap() { printf $'\e[H\e[2J'; pwb restore; }

# The subscripts of the following must agree with the order
# of the elements in the following FILE_TYPES array:
is_executable(){ [ -n "$1" ] && [ "${1:0:1}" -eq 1 ]; }
is_directory() { [ -n "$1" ] && [ "${1:2:1}" -eq 1 ]; }
is_link()      { [ -n "$1" ] &&[ "${1:4:2}" -eq 1 ]; }

is_man()       { [[ "$1" =~ ^.*\.[1-9](\.gz)?$ ]]; }
is_markdown()  { [[ "$1" =~ ^.*\.(md|MD)$ ]]; }

is_typeable()
{
    if [ "${#1}" -eq 1 ]; then
        local -i val
        printf -v val '%d' "'$1"
        if (( val >= 30 && val < 127 )); then
            return 0
        fi
    fi

    return 1
}

confirm_action()
{
    local -a ac_lines=(
        "Confirm $1"
        ""
        "Y or N?"
        )

    local -a allowed=( y Y n N key_escape )
    local ca_keyp
    pwb_conduct_dialog ac_lines SI_HANDLE -a allowed -r ca_keyp
    [[ "$ca_keyp" =~ Y|y ]]
}


prepare_view_call_args()
{
    app_installed() { type "$1" >/dev/null 2>&1; }

    local -a bat_args=(
        --paging always
        --style plain,header-filename,grid
    )
    local -n pvca_return="$1"
    if app_installed "bat"; then
        pvca_return=( "bat" "${bat_args[@]}" )
    elif app_installed "batcat"; then
        pvca_return=( "batcat" "${bat_args[@]}" )
    else
        pvca_return=( less )
    fi
}

############################
###   EXECUTION BEGINS   ###
############################


###   App Running Data  ###

declare -a MIME_TYPE_BLACKLIST=(
    ^inode/.*$
)

declare -a MIME_APP_BLACKLIST=(
    ^emacsclient\..*$
)

enable pwb

declare -a PSOURCES=(
    pwb_exit_on_error
    pwb_conduct_dialog
    pwb_get_regions
    pwb_print_array
    pwb_get_scroll_bar
    pwb_get_margins
    pwb_keybinder
)
source <( pwb_sources "${PSOURCES[@]}" )

declare -a KBINDINGS=(
    "key_f1"     exec_help    "Show help"

    # directory actions
    "key_right"  exec_enter   "Enter directory"
    "key_left"   exec_return  "Exit directory"
    "key_escape" exec_return  "Exit directory"

    # selected file actions
    $'\cm'       exec_default "Do default action"
    "e"          exec_edit    "Open file in editor"
    "v"          exec_view    "Open file in pager"
    "x"          exec_execute "Execute command"
    "l"          exec_launch  "Launch file"
    "d"          exec_delete  "Delete file"
    "key_dc"     exec_delete  "Delete file"

    "/"          exec_search  "Search for match"
)

declare KEYMAP
declare -a KEYFUNCS
pwb_keybinder prep KBINDINGS -v KEYMAP -f KEYFUNCS

declare DELIM="|"     # general arrays
declare FDELIM=":"    # for flags subarray

declare -a STAT_ATOMS=(
    n "file name"
    F "file type"
    s "size in bytes"
    G "owner group"
    U "owner name"
    a "octal permission"
    A "human permission"
)

# Fields are option, dircolors name, dircolors color.
# The first field is an option of 'test' / '[' that
# identifies a trait, the second field is 'LS_COLORS'
# file-type flag, and the third field will be the color
# defined by the LS_COLORS/dircolors entry for that file
# type.
#
# The colors are set with 'assign_file_type_colors'.
# The order is significant, when a file sports more than
# one trait, the last match is the color used.
#
# If a file matches none of the FILE_TYPES entries, it
# will be displayed in the default color.
#
# NOTE: the triads influence the members and order of
#       the file flags generated by 'get_file_flags',
#       and thus the appropriate index of tests for
#       the flags.  Changes here will probably affect
#       the 'is_executable/is_directory/is_link test
#       functions.
declare -a FILE_TYPES=(
    "-x"  "ex"  0  # executable
    "-d"  "di"  0  # directory
    "-h"  "ln"  0  # symbolic link
    # "-b"  "bd"  0  # block special
    # "-c"  "cd"  0  # char special
    # "-g"  "sg"  0  # set group-id
    # "-k"  "st"  0  # sticky
    # "-p"  "pi"  0  # named pipe
    # "-S"  "so"  0  # socket
    # "-u"  "su"  0  # set user-id
)
assign_file_type_colors FILE_TYPES

trap exit_trap EXIT SIGINT SIGABRT
pwb init

declare OG_DIR="$PWD"

if [ "$#" -gt 0 ]; then
    cd "$1"
fi

declare -a DIR_STEPS=( "$PWD" )

# Setup to use bat/batcat, if available, for viewing files
declare -a VIEW_CALL_ARGS
prepare_view_call_args VIEW_CALL_ARGS

start_instance

cd "$OG_DIR"
