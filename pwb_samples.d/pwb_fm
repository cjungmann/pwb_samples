#!/usr/bin/env bash

##########################
###   DATA FUNCTIONS   ###
##########################

get_context_data()
{
    local -n gcd_return="$1"

    shopt -s nullglob
    local -a gcd_files=( * )
    shopt -u nullglob
    if [ "${#gcd_files[*]}" -gt 0 ]; then
        local gcd_format
        make_stat_format gcd_format STAT_ATOMS

        local IFS="$DELIM"
        local -a gcd_row
        local -a gcd_type
        local -a gcd_flags
        local gcd_filename

        while read -r; do
            gcd_row=( $REPLY )
            gcd_filename="${gcd_row[0]}"
            get_file_flags gcd_flags  "$gcd_filename"

            IFS="$FDELIM"
            gcd_row=( "${gcd_flags[*]}" "$gcd_filename" "${gcd_row[@]:1}" )
            IFS="$DELIM"

            gcd_return+=( "${gcd_row[*]}" )
        done < <( stat -c "$gcd_format" "${gcd_files[@]}" )
    else
        gcd_return=()
    fi
}

remove_context_row()
{
    local -i rcr_index="$1"
    local -i rcr_total="${#SI_DATA[*]}"

    local -a rcr_left
    local -a rcr_right

    if (( rcr_index > 0 )); then
        rcr_left=( "${SI_DATA[@]:0:$rcr_index}" )
        # Move up a line before removing it
        pwb trigger SI_HANDLE 2
    fi
    if (( rcr_index < rcr_total )); then
        rcr_right=( "${SI_DATA[@]:$(( rcr_index+1 ))}" )
    fi

    SI_DATA=( "${rcr_left[@]}" "${rcr_right[@]}" )
    SI_DATA_COUNT="${#SI_DATA[*]}"
    pwb set_data_count SI_HANDLE "$SI_DATA_COUNT"
    pwb_exit_on_error
}


################################
###   STAT_ATOMS FUNCTIONS   ###
################################

make_stat_format()
{
    local -n msf_return="$1"
    local -n mfs_atoms="$2"

    local -a mfs_parts
    local -a row
    local -i count=0

    for atom in "${mfs_atoms[@]}"; do
        if [ "$count" -eq 0 ]; then
            mfs_parts+=( "%$atom" )
            (( ++count ))
        else
            count=0
        fi
    done

    local IFS="$DELIM"
    msf_return="${mfs_parts[*]}"
}

get_file_flags()
{
    local -n gff_return="$1"
    local gff_file="$2"
    local -a gff_row
    local gff_color=0

    gff_return=()

    for el in "${FILE_TYPES[@]}"; do
        gff_row+=( "$el" )
        if [ "${#gff_row[*]}" -eq 3 ]; then
            if [ "${gff_row[0]}" "$gff_file" ]; then
                gff_return+=( 1 )
                gff_color="${gff_row[2]}"
            else
                gff_return+=( 0 )
            fi
            gff_row=()
        fi
    done

    gff_return+=( "$gff_color" )
}

# Update FILE_TYPES array with colors according to 'dircolors' entry.
assign_file_type_colors()
{
    local -n aftc_colors="$1"

    local aftc_dircolors
    if [ -n "$LS_COLORS" ]; then
        aftc_dircolors="$LS_COLORS"
    else
        local raw_colors=$( dircolors -c )
        if [[ "$raw_colors" =~ ^[^\']+\'([^\']+)$ ]]; then
            aftc_dircolors="${BASH_REMATCH[0]}"
        fi
    fi

    local -a new_colors
    local -a aftc_row

    for el in "${aftc_colors[@]}"; do
        aftc_row+=( "$el" )
        if [ "${#aftc_row[*]}" -eq 3 ]; then
            local regex="${aftc_row[1]}=([^:]+)"
            if [[ "$aftc_dircolors" =~ $regex ]]; then
                aftc_row[2]="${BASH_REMATCH[1]}"
            else
                aftc_row[2]="$el"
            fi
            new_colors+=( "${aftc_row[@]}" )
            aftc_row=()
        fi
    done

    aftc_colors=( "${new_colors[@]}" )
}

###########################
###   BOUND FUNCTIONS   ###
###########################

# enter directory for exec_enter AND exec_default
exec_name_enter()
{
    local ene_name="$1"
    DIR_STEPS+=( "$ene_name" )
    local ENE_OG_DIR="$PWD"
    cd "$ene_name"
    printf $'\e[H\e[2J'
    start_instance
    DIR_STEPS=( "${DIR_STEPS[@]:0:${#DIR_STEPS[*]}-1}" )
    cd "$ENE_OG_DIR"
}

# execute name for exec_enter AND exec_default
exec_name_execute()
{
    local ene_name="$1"
    printf $'\e[H\e[2J'
    "$ene_name"
}

exec_template()
{
    local -n et_array="$3"
    local -a et_row
    IFS="$DELIM" read -r -a et_row <<< "${et_array[$2]}"
    local et_type="${et_row[0]}"
    local et_name="${et_row[1]}"
}

exec_help()
{
    local eh_keyp
    pwb_keybinder help KBINDINGS -v eh_keyp

    shift
    exec_line "$eh_keyp" "$@"
    local -i ecode="$?"
    if [[ "$eh_keyp" == 'q' ]] || [ "$ecode" -ne 0 ]; then
        return 1
    fi
}

exec_return()
{
    return 1
}

exec_delete()
{
    local -n et_array="$3"
    local -a et_row
    IFS="$DELIM" read -r -a et_row <<< "${et_array[$2]}"
    local et_type="${et_row[0]}"
    local et_name="${et_row[1]}"

    if ! is_directory "$et_type"; then
        if confirm_action "Delete file '$et_name'"; then
            rm "$et_name"
            remove_context_row "$2"
        fi
    fi
}

exec_enter()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"

    if is_directory "${ee_row[0]}"; then
        exec_name_enter "${ee_row[1]}"
    fi

    return 0
}

exec_execute()
{
    local -n ee_array="$3"
    local -a ee_row
    IFS="$DELIM" read -r -a ee_row <<< "${ee_array[$2]}"
    local ee_type="${ee_row[0]}"

    if is_executable "$ee_type"; then
        exec_name_execute "${ee_row[1]}"
    fi
}

exec_default()
{
    local -n ed_array="$3"
    local -a ed_row
    IFS="$DELIM" read -r -a ed_row <<< "${ed_array[$2]}"
    local ed_type="${ed_row[0]}"
    local ed_name="${ed_row[1]}"
    if is_directory "$ed_type"; then
        exec_name_enter "$ed_name"
    elif is_executable "$ed_type"; then
        exec_name_execute "$ed_name"
    fi
}


#########################
###   PWB CALLBACKS   ###
#########################

print_line()
{
    local -n pl_dsource="$2"
    local -a pl_row
    IFS="$DELIM" read -r -a pl_row <<< "${pl_dsource[$1]}"

    # First element is a compressed array of flags, the last
    # of which is the color to use to display the name:
    local col="${pl_row[0]}"
    col="${col##*$FDELIM}"
    if [[ "$col" == "0" ]]; then
        printf "%-*.*s" "$3" "$3" "${pl_row[1]}"
    else
        printf $'\e[%sm' "$col"
        printf "%-*.*s" "$3" "$3" "${pl_row[1]}"
        printf $'\e[m'
    fi
}

noop_print_left() { :; }
print_left()
{
    local -i index="$1"
    local pl_handle="$5"

    local limit_args=(
        -t "${SI_REGIONS[LM_TOP]}"
        -c "${SI_REGIONS[LM_LINES]}"
        -l "${SI_REGIONS[LM_LEFT]}"
        -w "${SI_REGIONS[LM_WIDE]}"
    )

    local -i left=$(( SI_REGIONS[LM_WIDE] - 2 ))

    local -i rows top
    pwb get_data_count "$pl_handle" -v rows
    pwb get_top_row "$pl_handle" -v top

    local -a scrollbar_args=(
        -s "$rows"
        -t "$top"
        -v "${SI_REGIONS[LM_LINES]}"
    )

    local -a pl_scrollbar
    pwb_get_scroll_bar pl_scrollbar "${scrollbar_args[@]}"

    for block in "${pl_scrollbar[@]}"; do
        printf $'\e[%dG%s\e[1D\e[1E' "$left" "$block"
    done
}

print_top()
{
    local limit_args=(
        -t "${SI_REGIONS[TM_TOP]}"
        -c "${SI_REGIONS[TM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -a pt_lines=( "PWB TEMPLATE BASE" )

    local IFS="/"
    printf -v pt_lines["${#pt_lines[*]}"] "%s" "${DIR_STEPS[*]}"
    printf -v pt_lines["${#pt_lines[*]}"] "Press F1 for help"

    pwb_print_array pt_lines "${limit_args[@]}"
}

print_bottom()
{
    local limit_args=(
        -t "${SI_REGIONS[BM_TOP]}"
        -c "${SI_REGIONS[BM_LINES]}"
        -l "${SI_REGIONS[SC_LEFT]}"
        -w "${SI_REGIONS[SC_WIDE]}"
    )

    local -i index="$1"
    local -i total="${#SI_DATA[*]}"
    local -a lines
    printf -v lines[0] $'Record \e[33;1m%d\e[39;22m out of \e[33;1m%d\e[39;22m' \
           $(( index+1 )) "$total"

    pwb_print_array lines "${limit_args[@]}"
}


exec_line()
{
    local keyp="$1"
    local el_handle="$4"

    local -i ecode=0
    local el_func
    if pwb_keybinder func KEYFUNCS -v el_func -k "$keyp"; then
        "$el_func" "$@"
        ecode="$?"
        printf $'\e[H\e[2J'
        pwb print_all "$el_handle"
    fi

    return "$ecode"
}


###################################
###   INSTANCE PREP FUNCTIONS   ###
###################################

get_content_width()
{
    local -n gcw_wide="$1"
    local -n gcw_array="$2"

    local -i cur_wide
    gcw_wide=0
    for line in "${gcw_array[@]}"; do
        cur_wide="${#line}"
        (( gcw_wide = ( cur_wide >gcw_wide ? cur_wide : gcw_wide ) ))
    done
}

set_instance_margins()
{
    local sim_handle="$1"
    local sim_data="$2"

    local -i data_width
    get_content_width data_width "$sim_data"

    local -A sim_dims
    pwb get_dimensions -A sim_dims

    local -i non_content=$(( sim_dims[screen_cols] - data_width ))
    local -i left right
    (( right = non_content / 2 ))
    (( left = right + (non_content % 2) ))

    local -a sim_margins=( 5 "$right" 2 "$left" )

    pwb set_margins "$sim_handle" "${sim_margins[@]}"
}

start_instance()
{
    # Prepare Data
    local -a SI_DATA
    get_context_data SI_DATA
    local -i SI_DATA_COUNT="${#SI_DATA[*]}"

    local print_left_func=print_left
    p_print_left() { "$print_left_func" "$@"; }

    # Create Handle
    local -a declare_args=(
        SI_DATA
        "$SI_DATA_COUNT"
        print_line
        -e exec_line
        -b print_bottom
        -t print_top
        -l p_print_left
    )

    local SI_HANDLE
    pwb declare SI_HANDLE "${declare_args[@]}"
    pwb_exit_on_error

    # Prepare Handle
    set_instance_margins SI_HANDLE SI_DATA

    # With margins established, get instance-global regions
    local -A SI_REGIONS
    pwb_get_regions SI_REGIONS SI_HANDLE

    # Use do-nothing function for scrollbar not needed:
    if (( SI_DATA_COUNT <= SI_REGIONS[CO_LINES] )); then
        print_left_func=noop_print_left
    fi

    local ending_keyp
    declare -a start_args=(
        -a KEYMAP
        -k ending_keyp
    )

    pwb start SI_HANDLE "${start_args[@]}"
    pwb_exit_on_error

    if [[ "$ending_keyp" == 'q' ]]; then
        exit 0
    fi
}

#########################
###   MISCELLANEOUS   ###
#########################

exit_trap() { printf $'\e[H\e[2J'; pwb restore; }

# The subscripts of the following must agree with the order
# of the elements in the following FILE_TYPES array:
is_executable(){ [ "${1:0:1}" -eq 1 ]; }
is_directory() { [ "${1:2:1}" -eq 1 ]; }
is_link()      { [ "${1:4:2}" -eq 1 ]; }

confirm_action()
{
    local -a ac_lines=(
        "Confirm $1"
        ""
        "Y or N?"
        )

    local -a allowed=( y Y n N key_escape )
    local ca_keyp
    pwb_conduct_dialog ac_lines SI_HANDLE -a allowed -r ca_keyp
    [[ "$ca_keyp" =~ Y|y ]]
}

############################
###   EXECUTION BEGINS   ###
############################

enable pwb

declare -a PSOURCES=(
    pwb_exit_on_error
    pwb_conduct_dialog
    pwb_get_regions
    pwb_print_array
    pwb_get_scroll_bar
    pwb_keybinder
)
source <( pwb_sources "${PSOURCES[@]}" )

declare -a KBINDINGS=(
    "key_f1"     exec_help    "Show help"
    "key_right"  exec_enter   "Enter directory"
    "key_left"   exec_return  "Exit directory"
    "key_escape" exec_return  "Return"
    "x"          exec_execute "Execute command"
    $'\cm'       exec_default "Do default action"
    "d"          exec_delete  "Delete file"
)

declare KEYMAP
declare -a KEYFUNCS
pwb_keybinder prep KBINDINGS -v KEYMAP -f KEYFUNCS

declare DELIM="|"     # general arrays
declare FDELIM=":"    # for flags subarray

declare -a STAT_ATOMS=(
    n "file name"
    F "file type"
    s "size in bytes"
    G "owner group"
    U "owner name"
    a "octal permission"
    A "human permission"
)

# Fields are option, dircolors name, dircolors color.
# The first field is an option of 'test' / '[' that
# identifies a trait, the second field is 'LS_COLORS'
# file-type flag, and the third field will be the color
# defined by the LS_COLORS/dircolors entry for that file
# type.
#
# The colors are set with 'assign_file_type_colors'.
# The order is significant, when a file sports more than
# one trait, the last match is the color used.
#
# If a file matches none of the FILE_TYPES entries, it
# will be displayed in the default color.
declare -a FILE_TYPES=(
    "-x"  "ex"  0  # executable
    "-d"  "di"  0  # directory
    "-h"  "ln"  0  # symbolic link
    # "-b"  "bd"  0  # block special
    # "-c"  "cd"  0  # char special
    # "-g"  "sg"  0  # set group-id
    # "-k"  "st"  0  # sticky
    # "-p"  "pi"  0  # named pipe
    # "-S"  "so"  0  # socket
    # "-u"  "su"  0  # set user-id
)
assign_file_type_colors FILE_TYPES

trap exit_trap EXIT SIGINT SIGABRT
pwb init

declare OG_DIR="$PWD"

if [ "$#" -gt 0 ]; then
    cd "$1"
fi

declare -a DIR_STEPS=( "$PWD" )

start_instance

cd "$OG_DIR"
